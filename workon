#!/bin/bash

# workon - Create a git worktree with a new branch and start claude on a task

set -e

VERSION="1.1.0"

#######################################
# Display help message
#######################################
show_help() {
    cat << 'EOF'
workon - Spin up an isolated git worktree and launch Claude to work on a task

USAGE
    workon [OPTIONS] <description>
    workon init
    workon --list
    workon --done <branch>

COMMANDS
    workon <description>
        Create a new worktree and launch Claude with the given task.

    workon init
        Initialize a .workon/ configuration folder in the current repo.
        Provides interactive template selection for prework/postwork scripts.

    workon --list
        Show all active worktrees for this repository.

    workon --done <branch>
        Clean up a worktree: runs postwork.sh, removes worktree and branch.

DESCRIPTION
    workon streamlines the process of starting work on a new feature or bug fix.
    It creates an isolated git worktree with a fresh branch, so you can work on
    multiple tasks in parallel without stashing or switching branches.

    The workflow:
      1. Generates a clean, descriptive branch name using OpenAI
      2. Creates a new worktree in .worktrees/<branch-name>/ inside your repo
      3. Runs .workon/prework.sh if it exists (e.g., copy .env, symlink modules)
      4. Bases the branch on the latest origin/main (or default branch)
      5. Launches Claude Code in the worktree with your task description

    When you're done:
      workon --done <branch-name>

CONFIGURATION
    The .workon/ folder in your repo root contains hooks and configuration:

        my-repo/
        ├── .workon/
        │   ├── prework.sh      # Runs after worktree creation
        │   └── postwork.sh     # Runs before worktree removal
        ├── .worktrees/         # Worktrees live here (gitignored)
        └── src/

    Run 'workon init' to set up this folder with templates for your project type.

    Hook scripts receive these environment variables:
        WORKON_MAIN_REPO    Path to the main repository
        WORKON_WORKTREE     Path to the worktree
        WORKON_BRANCH       Branch name
        WORKON_DESCRIPTION  Task description (prework only)

ARGUMENTS
    <description>
        A plain-text description of the feature, bug fix, or task you want to
        work on. This is passed directly to Claude and used to generate the
        branch name.

        Examples:
          "implement user profile photo upload"
          "fix memory leak in websocket handler"
          "refactor database connection pooling"

OPTIONS
    -h, --help
        Show this help message and exit.

    -v, --version
        Show version information and exit.

    -n, --dry-run
        Show what would be done without actually creating the worktree
        or launching Claude.

    -b, --branch <name>
        Use a specific branch name instead of auto-generating one.

    --no-claude
        Create the worktree and branch but don't launch Claude.
        Useful if you want to set up the workspace first.

    --list
        List all active worktrees for this repository.

    --done <branch>
        Clean up the specified worktree. Runs postwork.sh if it exists,
        then removes the worktree and deletes the branch.

EXAMPLES
    Initialize workon for a Next.js project:
        $ cd ~/projects/my-app
        $ workon init

    Start working on a new feature:
        $ workon "add dark mode support to the settings page"

    Fix a bug with a custom branch name:
        $ workon -b hotfix/login-redirect "fix redirect loop on login"

    Preview what would happen:
        $ workon --dry-run "refactor the API client"

    List active worktrees:
        $ workon --list

    Clean up when done:
        $ workon --done feat/dark-mode-support

ENVIRONMENT
    OPENAI_API_KEY
        Required for LLM-generated branch names. If not set, falls back to
        simple text sanitization of the description.

REQUIREMENTS
    - Must be run from inside a git repository
    - Requires 'claude' CLI to be installed and in PATH
    - Requires 'jq' for parsing OpenAI API responses (optional, for LLM naming)
    - Requires 'curl' for API calls (optional, for LLM naming)

SEE ALSO
    git-worktree(1), claude(1)

EOF
}

#######################################
# Display version
#######################################
show_version() {
    echo "workon $VERSION"
}

#######################################
# Generate branch name using LLM
#######################################
generate_branch_name() {
    local description="$1"

    # Check for API key
    if [ -z "$OPENAI_API_KEY" ]; then
        echo "Warning: OPENAI_API_KEY not set, using fallback branch naming" >&2
        fallback_branch_name "$description"
        return
    fi

    # Check for required tools
    if ! command -v jq &> /dev/null; then
        echo "Warning: jq not installed, using fallback branch naming" >&2
        fallback_branch_name "$description"
        return
    fi

    local prompt="Generate a git branch name for: \"$description\". Rules: lowercase letters, numbers, hyphens only. Max 40 chars. Use prefixes: feat/, fix/, refactor/, docs/, chore/. Output ONLY the branch name, nothing else."

    local response
    response=$(curl -s --max-time 10 https://api.openai.com/v1/chat/completions \
        -H "Authorization: Bearer $OPENAI_API_KEY" \
        -H "Content-Type: application/json" \
        -d '{
            "model": "gpt-4o-mini",
            "messages": [{"role": "user", "content": "'"${prompt//\"/\\\"}"'"}],
            "max_tokens": 50,
            "temperature": 0.3
        }' 2>/dev/null)

    local branch_name
    branch_name=$(echo "$response" | jq -r '.choices[0].message.content // empty' 2>/dev/null | tr -d '[:space:]' | head -c 50)

    # Fallback if LLM call fails
    if [ -z "$branch_name" ] || [ ${#branch_name} -lt 3 ]; then
        fallback_branch_name "$description"
        return
    fi

    echo "$branch_name"
}

#######################################
# Fallback branch name generation
#######################################
fallback_branch_name() {
    local description="$1"
    echo "$description" | \
        tr '[:upper:]' '[:lower:]' | \
        sed 's/[^a-z0-9]/-/g' | \
        sed 's/--*/-/g' | \
        sed 's/^-//' | \
        sed 's/-$//' | \
        cut -c1-40
}

#######################################
# Ensure .worktrees is gitignored
#######################################
ensure_gitignore() {
    local repo_root="$1"
    local gitignore="$repo_root/.gitignore"

    if [ -f "$gitignore" ]; then
        if ! grep -q "^\.worktrees/?$" "$gitignore" 2>/dev/null; then
            echo "" >> "$gitignore"
            echo "# workon script worktrees" >> "$gitignore"
            echo ".worktrees/" >> "$gitignore"
            echo "Added .worktrees/ to .gitignore"
        fi
    else
        echo "# workon script worktrees" > "$gitignore"
        echo ".worktrees/" >> "$gitignore"
        echo "Created .gitignore with .worktrees/"
    fi
}

#######################################
# Run prework script
#######################################
run_prework() {
    local repo_root="$1"
    local worktree_dir="$2"
    local branch_name="$3"
    local description="$4"

    local prework_script="$repo_root/.workon/prework.sh"

    if [ -f "$prework_script" ]; then
        echo "Running prework script..."
        (
            export WORKON_MAIN_REPO="$repo_root"
            export WORKON_WORKTREE="$worktree_dir"
            export WORKON_BRANCH="$branch_name"
            export WORKON_DESCRIPTION="$description"
            cd "$worktree_dir"
            bash "$prework_script"
        )
        echo "Prework complete."
    fi
}

#######################################
# Run postwork script
#######################################
run_postwork() {
    local repo_root="$1"
    local worktree_dir="$2"
    local branch_name="$3"

    local postwork_script="$repo_root/.workon/postwork.sh"

    if [ -f "$postwork_script" ]; then
        echo "Running postwork script..."
        (
            export WORKON_MAIN_REPO="$repo_root"
            export WORKON_WORKTREE="$worktree_dir"
            export WORKON_BRANCH="$branch_name"
            cd "$worktree_dir"
            bash "$postwork_script"
        )
        echo "Postwork complete."
    fi
}

#######################################
# List worktrees
#######################################
list_worktrees() {
    local repo_root="$1"
    local worktrees_dir="$repo_root/.worktrees"

    if [ ! -d "$worktrees_dir" ]; then
        echo "No worktrees found."
        return
    fi

    echo "Active worktrees:"
    echo ""

    local count=0
    for dir in "$worktrees_dir"/*/; do
        if [ -d "$dir" ]; then
            local branch_name=$(basename "$dir")
            local last_modified=$(stat -f "%Sm" -t "%Y-%m-%d %H:%M" "$dir" 2>/dev/null || stat -c "%y" "$dir" 2>/dev/null | cut -d'.' -f1)
            printf "  %-40s  %s\n" "$branch_name" "$last_modified"
            ((count++)) || true
        fi
    done

    if [ $count -eq 0 ]; then
        echo "No worktrees found."
    else
        echo ""
        echo "$count worktree(s) active."
        echo ""
        echo "To clean up: workon --done <branch-name>"
    fi
}

#######################################
# Clean up worktree
#######################################
cleanup_worktree() {
    local repo_root="$1"
    local branch_name="$2"
    local worktree_dir="$repo_root/.worktrees/$branch_name"

    if [ ! -d "$worktree_dir" ]; then
        echo "Error: Worktree not found: $worktree_dir"
        echo ""
        echo "Available worktrees:"
        list_worktrees "$repo_root"
        exit 1
    fi

    echo "Cleaning up worktree: $branch_name"

    # Run postwork
    run_postwork "$repo_root" "$worktree_dir" "$branch_name"

    # Remove worktree
    echo "Removing worktree..."
    git worktree remove "$worktree_dir" --force

    # Delete branch
    echo "Deleting branch..."
    git branch -D "$branch_name" 2>/dev/null || echo "Branch already deleted or merged."

    echo ""
    echo "✓ Cleanup complete: $branch_name"
}

#######################################
# Initialize .workon folder
#######################################
init_workon() {
    local repo_root="$1"
    local workon_dir="$repo_root/.workon"

    if [ -d "$workon_dir" ]; then
        echo "Error: .workon/ already exists in this repository."
        echo "Remove it first if you want to reinitialize."
        exit 1
    fi

    echo "workon init - Configure worktree hooks for this repository"
    echo ""

    # Detect project type
    local detected_type="generic"
    if [ -f "$repo_root/package.json" ]; then
        if grep -q "next" "$repo_root/package.json" 2>/dev/null; then
            detected_type="nextjs"
        elif grep -q "react" "$repo_root/package.json" 2>/dev/null; then
            detected_type="react"
        else
            detected_type="node"
        fi
    elif [ -f "$repo_root/requirements.txt" ] || [ -f "$repo_root/pyproject.toml" ]; then
        detected_type="python"
    elif [ -f "$repo_root/go.mod" ]; then
        detected_type="go"
    elif [ -f "$repo_root/Cargo.toml" ]; then
        detected_type="rust"
    fi

    echo "Select a template for your prework/postwork scripts:"
    echo ""
    echo "  1) nextjs    - Copy .env.local, symlink node_modules"
    echo "  2) node      - Copy .env, symlink node_modules"
    echo "  3) python    - Copy .env, set up virtualenv"
    echo "  4) go        - Minimal setup"
    echo "  5) rust      - Symlink target directory"
    echo "  6) generic   - Empty scripts (customize yourself)"
    echo ""

    if [ "$detected_type" != "generic" ]; then
        echo "  Detected project type: $detected_type"
        echo ""
    fi

    read -p "Choose template [1-6]: " choice

    case "$choice" in
        1) template="nextjs" ;;
        2) template="node" ;;
        3) template="python" ;;
        4) template="go" ;;
        5) template="rust" ;;
        6|"") template="generic" ;;
        *)
            echo "Invalid choice. Using generic template."
            template="generic"
            ;;
    esac

    # Create .workon directory
    mkdir -p "$workon_dir"

    # Generate prework.sh based on template
    case "$template" in
        nextjs)
            cat > "$workon_dir/prework.sh" << 'PREWORK'
#!/bin/bash
# Prework script for Next.js projects
# Runs after worktree is created, before Claude launches

set -e

echo "Setting up Next.js worktree..."

# Copy environment files from main repo
if [ -f "$WORKON_MAIN_REPO/.env.local" ]; then
    cp "$WORKON_MAIN_REPO/.env.local" "$WORKON_WORKTREE/.env.local"
    echo "  ✓ Copied .env.local"
fi

if [ -f "$WORKON_MAIN_REPO/.env" ]; then
    cp "$WORKON_MAIN_REPO/.env" "$WORKON_WORKTREE/.env"
    echo "  ✓ Copied .env"
fi

# Symlink node_modules to save disk space and install time
if [ -d "$WORKON_MAIN_REPO/node_modules" ]; then
    ln -s "$WORKON_MAIN_REPO/node_modules" "$WORKON_WORKTREE/node_modules"
    echo "  ✓ Symlinked node_modules"
fi

# Symlink .next cache (optional - comment out if you want fresh builds)
# if [ -d "$WORKON_MAIN_REPO/.next" ]; then
#     ln -s "$WORKON_MAIN_REPO/.next" "$WORKON_WORKTREE/.next"
#     echo "  ✓ Symlinked .next cache"
# fi

echo "Setup complete!"
PREWORK
            ;;

        node)
            cat > "$workon_dir/prework.sh" << 'PREWORK'
#!/bin/bash
# Prework script for Node.js projects
# Runs after worktree is created, before Claude launches

set -e

echo "Setting up Node.js worktree..."

# Copy environment files from main repo
if [ -f "$WORKON_MAIN_REPO/.env" ]; then
    cp "$WORKON_MAIN_REPO/.env" "$WORKON_WORKTREE/.env"
    echo "  ✓ Copied .env"
fi

# Symlink node_modules to save disk space and install time
if [ -d "$WORKON_MAIN_REPO/node_modules" ]; then
    ln -s "$WORKON_MAIN_REPO/node_modules" "$WORKON_WORKTREE/node_modules"
    echo "  ✓ Symlinked node_modules"
fi

echo "Setup complete!"
PREWORK
            ;;

        python)
            cat > "$workon_dir/prework.sh" << 'PREWORK'
#!/bin/bash
# Prework script for Python projects
# Runs after worktree is created, before Claude launches

set -e

echo "Setting up Python worktree..."

# Copy environment files from main repo
if [ -f "$WORKON_MAIN_REPO/.env" ]; then
    cp "$WORKON_MAIN_REPO/.env" "$WORKON_WORKTREE/.env"
    echo "  ✓ Copied .env"
fi

# Option 1: Symlink virtualenv (faster, shared packages)
# if [ -d "$WORKON_MAIN_REPO/.venv" ]; then
#     ln -s "$WORKON_MAIN_REPO/.venv" "$WORKON_WORKTREE/.venv"
#     echo "  ✓ Symlinked .venv"
# fi

# Option 2: Create fresh virtualenv (isolated, but slower)
if [ -f "$WORKON_MAIN_REPO/requirements.txt" ]; then
    python3 -m venv "$WORKON_WORKTREE/.venv"
    source "$WORKON_WORKTREE/.venv/bin/activate"
    pip install -r "$WORKON_WORKTREE/requirements.txt" -q
    echo "  ✓ Created virtualenv and installed dependencies"
fi

echo "Setup complete!"
PREWORK
            ;;

        go)
            cat > "$workon_dir/prework.sh" << 'PREWORK'
#!/bin/bash
# Prework script for Go projects
# Runs after worktree is created, before Claude launches

set -e

echo "Setting up Go worktree..."

# Copy environment files from main repo
if [ -f "$WORKON_MAIN_REPO/.env" ]; then
    cp "$WORKON_MAIN_REPO/.env" "$WORKON_WORKTREE/.env"
    echo "  ✓ Copied .env"
fi

# Go modules are cached globally, so no symlinks needed
# Just ensure dependencies are available
if [ -f "$WORKON_WORKTREE/go.mod" ]; then
    cd "$WORKON_WORKTREE"
    go mod download
    echo "  ✓ Downloaded Go modules"
fi

echo "Setup complete!"
PREWORK
            ;;

        rust)
            cat > "$workon_dir/prework.sh" << 'PREWORK'
#!/bin/bash
# Prework script for Rust projects
# Runs after worktree is created, before Claude launches

set -e

echo "Setting up Rust worktree..."

# Copy environment files from main repo
if [ -f "$WORKON_MAIN_REPO/.env" ]; then
    cp "$WORKON_MAIN_REPO/.env" "$WORKON_WORKTREE/.env"
    echo "  ✓ Copied .env"
fi

# Symlink target directory to save disk space and compile time
if [ -d "$WORKON_MAIN_REPO/target" ]; then
    ln -s "$WORKON_MAIN_REPO/target" "$WORKON_WORKTREE/target"
    echo "  ✓ Symlinked target directory"
fi

echo "Setup complete!"
PREWORK
            ;;

        generic|*)
            cat > "$workon_dir/prework.sh" << 'PREWORK'
#!/bin/bash
# Prework script - runs after worktree is created, before Claude launches
#
# Available environment variables:
#   WORKON_MAIN_REPO    - Path to the main repository
#   WORKON_WORKTREE     - Path to this worktree
#   WORKON_BRANCH       - Branch name
#   WORKON_DESCRIPTION  - Task description
#
# Example tasks:
#   - Copy .env files: cp "$WORKON_MAIN_REPO/.env" "$WORKON_WORKTREE/.env"
#   - Symlink dependencies: ln -s "$WORKON_MAIN_REPO/node_modules" "$WORKON_WORKTREE/node_modules"
#   - Run setup scripts: npm install, pip install, etc.

set -e

echo "Running prework for: $WORKON_BRANCH"

# Add your setup commands here

echo "Prework complete!"
PREWORK
            ;;
    esac

    # Generate postwork.sh (similar for all templates)
    cat > "$workon_dir/postwork.sh" << 'POSTWORK'
#!/bin/bash
# Postwork script - runs before worktree is removed
#
# Available environment variables:
#   WORKON_MAIN_REPO    - Path to the main repository
#   WORKON_WORKTREE     - Path to this worktree
#   WORKON_BRANCH       - Branch name
#
# Example tasks:
#   - Clean up temp files
#   - Export any generated data
#   - Run cleanup scripts

set -e

echo "Running postwork for: $WORKON_BRANCH"

# Remove symlinks (they'll cause issues with worktree removal otherwise)
find "$WORKON_WORKTREE" -maxdepth 1 -type l -delete 2>/dev/null || true

echo "Postwork complete!"
POSTWORK

    # Make scripts executable
    chmod +x "$workon_dir/prework.sh"
    chmod +x "$workon_dir/postwork.sh"

    # Ensure .worktrees is gitignored
    ensure_gitignore "$repo_root"

    echo ""
    echo "✓ Created .workon/ with $template template"
    echo ""
    echo "Files created:"
    echo "  .workon/prework.sh   - Runs after worktree creation"
    echo "  .workon/postwork.sh  - Runs before worktree removal"
    echo "  .gitignore           - Updated to exclude .worktrees/"
    echo ""
    echo "Edit these scripts to customize your workflow."
    echo "Commit .workon/ and .gitignore to your repository."
}

#######################################
# Main
#######################################

DRY_RUN=false
NO_CLAUDE=false
CUSTOM_BRANCH=""
LIST_MODE=false
DONE_BRANCH=""
INIT_MODE=false

# Parse options
while [[ $# -gt 0 ]]; do
    case "$1" in
        -h|--help)
            show_help
            exit 0
            ;;
        -v|--version)
            show_version
            exit 0
            ;;
        -n|--dry-run)
            DRY_RUN=true
            shift
            ;;
        --no-claude)
            NO_CLAUDE=true
            shift
            ;;
        -b|--branch)
            if [ -z "$2" ] || [[ "$2" == -* ]]; then
                echo "Error: --branch requires a branch name"
                exit 1
            fi
            CUSTOM_BRANCH="$2"
            shift 2
            ;;
        --list)
            LIST_MODE=true
            shift
            ;;
        --done)
            if [ -z "$2" ] || [[ "$2" == -* ]]; then
                echo "Error: --done requires a branch name"
                echo "Usage: workon --done <branch-name>"
                exit 1
            fi
            DONE_BRANCH="$2"
            shift 2
            ;;
        init)
            INIT_MODE=true
            shift
            ;;
        -*)
            echo "Error: Unknown option: $1"
            echo "Run 'workon --help' for usage information."
            exit 1
            ;;
        *)
            break
            ;;
    esac
done

# Check if we're in a git repo (required for all commands)
if ! git rev-parse --is-inside-work-tree > /dev/null 2>&1; then
    echo "Error: Not in a git repository"
    echo "Navigate to a git repository and try again."
    exit 1
fi

# Get repo info
REPO_ROOT=$(git rev-parse --show-toplevel)
REPO_NAME=$(basename "$REPO_ROOT")

# Handle init command
if [ "$INIT_MODE" = true ]; then
    init_workon "$REPO_ROOT"
    exit 0
fi

# Handle list command
if [ "$LIST_MODE" = true ]; then
    list_worktrees "$REPO_ROOT"
    exit 0
fi

# Handle done command
if [ -n "$DONE_BRANCH" ]; then
    cleanup_worktree "$REPO_ROOT" "$DONE_BRANCH"
    exit 0
fi

# Collect remaining args as description
DESCRIPTION="$*"

if [ -z "$DESCRIPTION" ]; then
    echo "Error: No task description provided"
    echo ""
    echo "Usage: workon <description>"
    echo "       workon \"add user authentication\""
    echo ""
    echo "Commands:"
    echo "       workon init          Initialize .workon/ config folder"
    echo "       workon --list        List active worktrees"
    echo "       workon --done <br>   Clean up a worktree"
    echo ""
    echo "Run 'workon --help' for more information."
    exit 1
fi

# Check if claude is available
if ! command -v claude &> /dev/null; then
    echo "Error: 'claude' CLI not found in PATH"
    echo "Install Claude Code: https://claude.ai/code"
    exit 1
fi

# Generate or use custom branch name
if [ -n "$CUSTOM_BRANCH" ]; then
    BRANCH_NAME="$CUSTOM_BRANCH"
    echo "Using custom branch name: $BRANCH_NAME"
else
    echo "Generating branch name..."
    BRANCH_NAME=$(generate_branch_name "$DESCRIPTION")
    echo "Branch name: $BRANCH_NAME"
fi

# Check if branch already exists
if git show-ref --verify --quiet "refs/heads/$BRANCH_NAME" 2>/dev/null; then
    echo "Error: Branch '$BRANCH_NAME' already exists"
    echo "Use --branch to specify a different name, or delete the existing branch."
    exit 1
fi

# Worktree location
WORKTREE_DIR="$REPO_ROOT/.worktrees/$BRANCH_NAME"

# Check if worktree directory already exists
if [ -d "$WORKTREE_DIR" ]; then
    echo "Error: Worktree directory already exists: $WORKTREE_DIR"
    exit 1
fi

# Get default branch
DEFAULT_BRANCH=$(git symbolic-ref refs/remotes/origin/HEAD 2>/dev/null | sed 's@^refs/remotes/origin/@@')
if [ -z "$DEFAULT_BRANCH" ]; then
    # Fallback: try common default branch names
    for branch in main master; do
        if git show-ref --verify --quiet "refs/remotes/origin/$branch" 2>/dev/null; then
            DEFAULT_BRANCH="$branch"
            break
        fi
    done
fi

if [ -z "$DEFAULT_BRANCH" ]; then
    echo "Error: Could not determine default branch"
    echo "Make sure you have a remote named 'origin' configured."
    exit 1
fi

# Dry run - show what would happen
if [ "$DRY_RUN" = true ]; then
    echo ""
    echo "=== DRY RUN ==="
    echo "Would perform the following actions:"
    echo ""
    echo "  1. Fetch latest from origin/$DEFAULT_BRANCH"
    echo "  2. Ensure .worktrees/ is in .gitignore"
    echo "  3. Create worktree:"
    echo "       Directory: $WORKTREE_DIR"
    echo "       Branch:    $BRANCH_NAME"
    echo "       Base:      origin/$DEFAULT_BRANCH"
    if [ -f "$REPO_ROOT/.workon/prework.sh" ]; then
        echo "  4. Run prework.sh"
    fi
    if [ "$NO_CLAUDE" = false ]; then
        echo "  5. Launch Claude with task:"
        echo "       \"$DESCRIPTION\""
    fi
    echo ""
    echo "No changes made."
    exit 0
fi

# Fetch latest
echo "Fetching latest from origin/$DEFAULT_BRANCH..."
git fetch origin "$DEFAULT_BRANCH" 2>/dev/null || {
    echo "Warning: Could not fetch from origin. Using local state."
}

# Ensure .worktrees is gitignored
ensure_gitignore "$REPO_ROOT"

# Create .worktrees directory
mkdir -p "$REPO_ROOT/.worktrees"

# Create worktree
echo "Creating worktree..."
git worktree add -b "$BRANCH_NAME" "$WORKTREE_DIR" "origin/$DEFAULT_BRANCH"

echo ""
echo "✓ Worktree created successfully"
echo "  Directory: $WORKTREE_DIR"
echo "  Branch:    $BRANCH_NAME"
echo ""

# Run prework
run_prework "$REPO_ROOT" "$WORKTREE_DIR" "$BRANCH_NAME" "$DESCRIPTION"

if [ "$NO_CLAUDE" = true ]; then
    echo "Skipping Claude launch (--no-claude specified)"
    echo ""
    echo "To enter the worktree:"
    echo "  cd $WORKTREE_DIR"
    exit 0
fi

# Change to worktree and run claude
cd "$WORKTREE_DIR"
echo ""
echo "Launching Claude..."
echo "Task: $DESCRIPTION"
echo ""

exec claude "$DESCRIPTION"
